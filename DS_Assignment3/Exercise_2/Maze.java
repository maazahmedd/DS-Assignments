import java.util.Random;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.ArrayList;

public class Maze {

    // basic maze components
    private final int WIDTH;
    private final int LENGTH;
    private Cell[][] maze;
    // start represents the starting Cell (top left)
    private Cell start;

    // wall_map is a hashmap with keys which are Cells and values which are lists which hold the neighboring walls not broken down
    private Map<Cell, List<Integer>> wall_map = new HashMap<>();
    private Random rand = new Random();
    // keyList is an array list which stores all keys of the hashmap
    private List<Cell> keyList = new ArrayList<>();


    // maze constructor
    public Maze(int width, int length) {
        this.WIDTH = width;
        this.LENGTH = length;
        maze = new Cell[WIDTH][LENGTH];

        for (int i = 0; i < WIDTH; ++i) {
            for (int j = 0; j < LENGTH; ++j) {
                maze[i][j] = new Cell(i, j);
            }
        }
        // assign start Cell
        start = maze[1][1];

        // setting the left and right boundaries for the maze
        for (int i = 1; i < WIDTH; i++) {
            maze[0][i].setLeft(false);
            maze[0][i].setRight(false);
            maze[0][i].setTop(false);
            maze[0][i].setBottom(false);
            maze[1][i].setLeft(true);
            maze[LENGTH - 1][i].setRight(true);
        }

        // setting top and bottom boundaries
        for (int i = 1; i < LENGTH; i++) {
            maze[i][0].setLeft(false);
            maze[i][0].setTop(false);
            maze[i][0].setRight(false);
            maze[i][0].setBottom(false);
            maze[i][1].setTop(true);
            maze[i][WIDTH - 1].setBottom(true);
        }
        // leaves starting and ending locations open
        maze[0][0].setRight(false);
        maze[0][0].setBottom(false);
        maze[1][1].setLeft(false);
        maze[LENGTH - 1][WIDTH - 1].setRight(false);
        
        prims(start);


    }

    public Cell[][] getMaze() {
        return maze;
    }

    private void prims(Cell root) {
        // finding walls associated with the root and storing them in a list which is returned by findWalls
        List<Integer> foundWalls = findWalls(root);
        if (foundWalls.size() > 0) {
            wall_map.put(root, foundWalls); 
        }
        // getting Cells (keys) in wall_map
        for (Cell key : wall_map.keySet()) {
            keyList.add(key);
        }
        // key (Cell) picked at random
        int index = rand.nextInt(keyList.size());
        Cell current = keyList.get(index); 


        // goes through wall_map until it is empty
        while (!wall_map.isEmpty()) {
            // after picking random wall from wall list
            current.setVisited(true);

            List<Integer> walls = wall_map.get(current); // get random list of walls from the chosen Cell
            int location = walls.get(rand.nextInt(walls.size())); // random wall (location) picked out of list

            // checks if opposite/neighbor Cell is in the maze or not
            // neighbor is not added to wall_map if it has been visited
            if (!neighborVisited(current, location)) {
                Cell nextCell = WallRemover(current, location); //Breaks into a new Cell and breaks wall
                nextCell.setVisited(true);
                List<Integer> w = findWalls(nextCell);
                if (w.size() > 0 && !keyList.contains(nextCell)) { //If neighbots exist and the nextCell has not been visited
                    keyList.add(nextCell);
                    wall_map.put(nextCell, w);
                }

            }
            // wall is removed from walls List
            // location must be cast to Integer before removing that from the list
            walls.remove((Integer) location); //Removing wall
            //Taking care of key that is mapped to walls
            if (walls.size() == 0) { //If all the walls have been checked removed the Cell
                wall_map.remove(current);
                keyList.remove(current);

                // gets out of the while loop when the wall_map is empty
                if (keyList.size() == 0) {
                    System.out.println("Maze generated by using Prim's Algorithm!");
                    break;
                }
            }
            index = rand.nextInt(keyList.size());
            current = keyList.get(index); //Finds a new Cell and starts over
        }
    }

    private List<Integer> findWalls(Cell curr) {
        List<Integer> walls = new ArrayList<>();
        if (curr != null) {
            Cell[] n = findNeighbors(curr.getX(), curr.getY()); //Current Cell X and Y value
            // finding neighbors which are the walls
            // finding walls that have not been torn down
            if (n[0] != null) {
                walls.add(0); //Left wall
            }
            if (n[1] != null) {
                walls.add(1); //Bottom wall
            }
            if (n[2] != null) {
                walls.add(2); //Right wall
            }
            if (n[3] != null) {
                walls.add(3); //Top wall
            }
        }
        return walls;
    }

    // checks to see if the neighbor has been visited
    // returns a boolean which is used in prims() method above
    private boolean neighborVisited(Cell current1, int location) {
        if (location == 0) {
            return maze[current1.getX() - 1][current1.getY()].getVisited();
        } else if (location == 1) {
            return maze[current1.getX()][current1.getY() - 1].getVisited();
        } else if (location == 2) {
            return maze[current1.getX() + 1][current1.getY()].getVisited();
        } else if (location == 3) {
            return maze[current1.getX()][current1.getY() + 1].getVisited();
        }
        return true;
    }

    // finding the neighbors for prim's algorithm
    // want to find neighbors that have not been visited
    // hence we can find walls that have not been visited
    private Cell[] findNeighbors(int x, int y) {
        Cell[] neighbors = new Cell[4];
        if (!((x-1) < 1) && !maze[x-1][y].getVisited()) {
            neighbors[0] = maze[x-1][y];
        }
        if (!((y-1) < 1) && !maze[x][y-1].getVisited()) {
            neighbors[1] = maze[x][y-1];
        }
        if (!((x+1) > (WIDTH-1)) && !maze[x+1][y].getVisited()) {
            neighbors[2] = maze[x+1][y];
        }
        if (!((y+1) > (LENGTH-1)) && !maze[x][y+1].getVisited()) {
            neighbors[3] = maze[x][y+1];
        }
        return neighbors;
    }

    // breaks down the walls (or edges) creating a pathway
    // depending on the locaton the wall is torn down
    private Cell WallRemover(Cell curr, int location) {
        if (curr != null) {
            //Returns the Cell the pointer is going into
            //Or the neighboring Cell
            if (location == 0) { //remove Left
                curr.setLeft(false);
                maze[curr.getX() - 1][curr.getY()].setRight(false);
                return maze[curr.getX() - 1][curr.getY()];
            } else if (location == 1) { //remove Bottom
                curr.setTop(false);
                maze[curr.getX()][curr.getY() - 1].setBottom(false);
                return maze[curr.getX()][curr.getY() - 1];
            } else if (location == 2) { //remove Right
                curr.setRight(false);
                maze[curr.getX() + 1][curr.getY()].setLeft(false);
                return maze[curr.getX() + 1][curr.getY()];
            } else if (location == 3) { //remove Top
                curr.setBottom(false);
                maze[curr.getX()][curr.getY() + 1].setTop(false);
                return maze[curr.getX()][curr.getY() + 1];
            }
            curr.setVisited(true);
        }
        return null;
    }

    public static void main(String[] args){
        Maze myMaze = new Maze(5, 5);
    }
}